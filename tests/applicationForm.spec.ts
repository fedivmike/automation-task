import { expect } from '@playwright/test';
import { test } from '../src/base/pomFixture';
import {
  InputTestData,
  invalidTestsData,
  relativePathsToImages,
} from '../src/testData/inputData';
import path from 'path';
import { 
  NO_AVATAR_UPLOADED, 
  PLEASE_FILL_OUT_THIS_FIELD, 
  SUCCESS, 
  SUCCESSFUL_FORM_SUBMISSIONS } from '../src/constants';

test('Verify that user is able to submit a form with valid data', async ({ applicationFormPage, successPage }) => {
  const data: InputTestData = {
    firstName: 'testA',
    lastName: 'testB',
    email: 'email@gmail.com',
    password: '123456789',
    isSliderUnlocked: true,
  };
  await applicationFormPage.fillInTheForm(data);

  const actualHeader = await successPage.getHeaderTxt();
  const actualData = await successPage.getData();
  const actualUrl = successPage.getURL();

  expect(actualHeader).toContain(SUCCESSFUL_FORM_SUBMISSIONS);
  expect(actualData).toContain(data.firstName);
  expect(actualData).toContain(data.lastName);
  expect(actualData).toContain(data.email);
  expect(actualData).toContain(NO_AVATAR_UPLOADED);
  expect(actualUrl).toContain(SUCCESS);
});

for (const dataSet of invalidTestsData) {
  test(`Verify that submission fails when ${dataSet.validationCondition}`, async ({ applicationFormPage }) => {
    console.log(dataSet.inputTestData.pathToFile);
    await applicationFormPage.fillInTheForm(dataSet.inputTestData);

    const actualErrorMessage = await applicationFormPage.getErrorMessageTxt();
    expect(actualErrorMessage).toEqual(dataSet.expectedTestData.errorMessage);

    const actualPageUrl = applicationFormPage.getURL();
    expect(actualPageUrl).not.toContain(
      dataSet.expectedTestData.notToContainUrl
    );
  });
}

/* In order to be correctly tested - validation messages should be generated by webpage, and not by the browser.
If validation logic is on the webpage (like with password length, captcha), 
then test data for the test would be included in previous test 
and as a result direct usage of locator would not be present*/
test('Verify that submission fails when email format is invalid and validation message appears', async ({ applicationFormPage }) => {
  const data: InputTestData = {
    firstName: 'testA',
    lastName: 'testB',
    email: 'ar@ar',
    password: '12345678',
    isSliderUnlocked: true,
  };

  await applicationFormPage.fillInTheForm(data);

  const actualValidationMessage = await applicationFormPage.emailLctr.evaluate((element) => {
      const input = element as HTMLInputElement;
      return input.validationMessage;
    }
  );
  expect(actualValidationMessage).toContain('Please');

  const actualPageUrl = applicationFormPage.getURL();
  expect(actualPageUrl).not.toContain(SUCCESS);
});

for (const pathAsString of relativePathsToImages) {
  test(`Verify that uploaded image is correctly displayed, located : ${pathAsString}`, async ({ applicationFormPage, successPage }) => {
    const data: InputTestData = {
      firstName: 'testA',
      lastName: 'testB',
      email: 'tar@mail.com',
      password: '12345678',
      isSliderUnlocked: true,
      pathToFile: path.join(__dirname, pathAsString),
    };

    await applicationFormPage.fillInTheForm(data);

    const isImageVisible = await successPage.isImageVisible();
    expect(isImageVisible).toBeTruthy();
  });
}

// Case when required field is not filled
test('Verify that validation message appears when required field is not filled during submit', async ({ applicationFormPage }) => {
  const data: InputTestData = {
    firstName: '',
    lastName: 'testB',
    email: 'email@gmail.com',
    password: '123456789',
  };
  await applicationFormPage.fillInTheForm(data);

  const actualValidationMessage =
    await applicationFormPage.firstNameLctr.evaluate((element) => {
      const input = element as HTMLInputElement;
      return input.validationMessage;
    });

  expect(actualValidationMessage).toEqual(PLEASE_FILL_OUT_THIS_FIELD);
});
